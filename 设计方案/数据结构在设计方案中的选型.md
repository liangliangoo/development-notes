# 设计方案 之 数据接口

## 场景一
### 需求背景描述
聊天室需要支持禁言功能，如果一个用户在聊天室A中被禁言，那么他将永久被禁言，知道管理员取消为止。

## 技术设计
### 我当时的设计方案：只要用户进入某个聊天室，将其标记为未被禁言状态，然后存储到Mysql中和用户行为相关的记录中user_biz_cache varchar(1024)。

## 线上问题
### 1、伴随着用户进入的聊天室增多，会挤爆user_biz_cache字段（存的是一个大JSON）
```java 
    /**
     * 判断用户在 room 中是否被禁言
     * @param appId
     * @param userId
     * @param roomId
     * @return
     */
    public Boolean getTabooStatus(Long appId, Long userId, Long roomId) {

        log.debug("getTabooStatus userId {} roomId {}", userId, roomId);

        if (Objects.isNull(roomId) || Objects.isNull(appId) || Objects.isNull(userId)) {
            throw new ServiceException(ErrorCode.INVALID_PARAM, "参数异常");
        }

        String key = String.format(TABOOSTATUS, roomId, userId);
        Object val = redisManager.get(key);
        if (Objects.nonNull(val)) {
            log.debug("getTabooStatus result {}",val.toString());
            return Boolean.valueOf(val.toString());
        } else {
            UserBizCacheDO userBizCache = getUserBizCache(appId, userId);
            log.debug("getTabooStatus userBizCache {}", JSONObject.toJSONString(userBizCache));
            Map<String, Object> bizCacheMap = Objects.isNull(userBizCache.getBizCacheMap()) ? new HashMap<>() : userBizCache.getBizCacheMap();
            if (Objects.nonNull(bizCacheMap.get(String.format(TABOO_CACHE_PREFIX, roomId)))) {
                Object newVal = userBizCache.getBizCacheMap().get(String.format(TABOO_CACHE_PREFIX, roomId));
                Boolean ans = Boolean.parseBoolean(newVal.toString());
                redisManager.set(key, ans, DateUtil.ONE_DAY_SECONDS);
                log.debug("getTabooStatus result {}",ans.toString());
                return ans;
            } else {
                Map<String, Object> cacheMap = CollectionUtils.isEmpty(userBizCache.getBizCacheMap()) ? new HashMap<>() : userBizCache.getBizCacheMap();
                cacheMap.put(String.format(TABOO_CACHE_PREFIX, roomId), Boolean.FALSE);
                userBizCache.setBizCache(JSONObject.toJSONString(cacheMap));
                userBizCacheJpaDAO.save(userBizCache);
                redisManager.set(key, Boolean.FALSE, DateUtil.ONE_DAY_SECONDS);
                log.debug("getTabooStatus result {}", false);
                return Boolean.FALSE;
            }
        }
    }
```
### 2、用户进入聊天室 会拿到何其自身相关的信息，我在此基础上添加了一个方法，起作用就是获取用户是否被禁言的状态，但是当 我的这个方法出现问题时，会导致用户进入聊天室失败

## 解决方案
### 1、缺省记录，因为绝大多的用户是不会被禁言的；通过集合存储
### 2、在原用功能上添加一个方法的时候，一定要将自己所添加的方法产生的异常catch掉 无论是否会跑出异常信息


